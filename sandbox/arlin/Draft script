# ==============================================================================
# PHASE 1: DATA PREPARATION & PREPROCESSING (DCM SUBSET)
# ==============================================================================

# 1. Load necessary libraries for data manipulation

analysis_packages <- c(
  "tidyverse", "tidyr", "dplyr", "gridExtra", "pcaMethods", 
  "data.table", "tableone", "kableExtra", "rmarkdown", 
  "readr", "readxl", "gprofiler2", "knitr"
)
for (pkg in analysis_packages) {
  if (!require(pkg, character.only = TRUE, quietly = TRUE)) {
    message(paste("Installing Analysis package:", pkg))
    install.packages(pkg, dependencies = TRUE)
  }
  library(pkg, character.only = TRUE)
}

if (!requireNamespace("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager")
}

# Define the list of BioConductor packages you need
bio_pkgs <- c("edgeR", "limma", "biomaRt")

# Check if BiocManager is installed, install if not
if (!require("BiocManager", quietly = TRUE)) install.packages("BiocManager")

# Loop through packages: Load them. If they fail to load, install them.
for (pkg in bio_pkgs) {
  if (!require(pkg, character.only = TRUE)) {
    message(paste("Installing missing package:", pkg))
    BiocManager::install(pkg, update = FALSE, ask = FALSE)
    library(pkg, character.only = TRUE)
  } else {
    message(paste("Package loaded successfully:", pkg))
  }
}

#Confirm necessary packages for this section
library(readr)
require(readr)
library(readxl)
require(readxl)



#The next code allows you to check your directory file, c=make sure to have the 
#data in the same file, as a result you have set the script location

if (requireNamespace("rstudioapi", quietly = TRUE) && rstudioapi::isAvailable()) {
  current_dir <- dirname(rstudioapi::getActiveDocumentContext()$path)
  setwd(current_dir)
  message(paste("Working directory set to script location:", getwd()))
} else {
  # Fallback: If not in RStudio, the user must ensure they are running the script
  # from the correct location, or you can add a generic error message/stop.
  warning("Not running in RStudio. Please set working directory manually for portability.")
}

if (requireNamespace("rstudioapi", quietly = TRUE) && rstudioapi::isAvailable()) {
  current_dir <- dirname(rstudioapi::getActiveDocumentContext()$path)
  setwd(current_dir)
  message(paste("Working directory set to script location:", getwd()))
} else {
  # Fallback: If not in RStudio, the user must ensure they are running the script
  # from the correct location, or you can add a generic error message/stop.
  warning("Not running in RStudio. Please set working directory manually for portability.")
}

sample_data <- read.csv("MAGNET_SampleData_18112022.csv", as.is = T, 
                        row.names = 1)

gene_expression <- read.delim("MAGNET_GeneExpressionData_CPM_19112020.txt", as.is = T,
                              row.names = 1)


exons_lenght <-  read.delim("MAGNET_exonLengths.txt", as.is = T, 
                            row.names = 1) 


data_description <- read_excel("MAGNET_SampleData_18112022_WithDescriptions.xlsx")

View(data_description)

# ------------------------------------------------------------------------------
# 1. SUBSET METADATA FOR DCM PATIENTS
# ------------------------------------------------------------------------------
# We focus strictly on Dilated Cardiomyopathy as per your research question.

dcm_meta <- sample_data %>%
  filter(etiology == "DCM")

# Check how many patients we have
print(paste("Total DCM Patients for Analysis:", nrow(dcm_meta)))


library(biomaRt)
library(dplyr)

# 1. DATA ALIGNMENT (CRITICAL)
# We need to ensure the gene lengths file matches the expression matrix rows exactly.
common_samples <- intersect(rownames(dcm_meta), colnames(gene_expression))
dcm_expr_raw <- gene_expression[, common_samples]
dcm_meta <- dcm_meta[common_samples, ]
print(paste("Data Loaded: ", ncol(dcm_expr_raw)))

# 2. DEFINE FPKM FUNCTION
# Converts counts to abundance by correcting for gene length and library size.
cpm2fpkm <- function(counts, lengths) {
  # Library size in Millions
  lib_sizes <- colSums(counts) / 1e6
  # Matrix multiplication to adjust for library size
  rpm <- t(t(counts) / lib_sizes)
  # Adjust for gene length (kb) - assuming length column is index 1
  fpkm <- rpm / (lengths[, 1] / 1000)
  return(fpkm)
}

# Calculate FPKM for the whole dataset
dcm_fpkm <- cpm2fpkm(dcm_expr_raw, exons_lenght)

# 3. IDENTIFY Y-CHROMOSOME GENES (THE "NEGATIVE CONTROLS")
# Connect to Ensembl to find which genes are on the Y chromosome
ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
gene_map <- getBM(attributes = c("ensembl_gene_id", "chromosome_name"),
                  filters = "ensembl_gene_id",
                  values = rownames(dcm_expr_raw),
                  mart = ensembl)

# Extract only Y-chromosome IDs
y_genes <- gene_map %>%
  filter(chromosome_name == "Y") %>%
  pull(ensembl_gene_id)

# 4. CALCULATE BACKGROUND THRESHOLD
# Identify Female DCM patients (They should have 0 expression of Y genes)
female_samples <- rownames(dcm_meta[dcm_meta$gender == "Female", ])

# Safety check: keep only female samples that exist in our expression data
female_samples <- intersect(female_samples, colnames(dcm_fpkm))

# Get the expression (FPKM) of Y-genes in these Female patients
# We only look at Y genes that actually exist in our dataset
y_genes_present <- intersect(y_genes, rownames(dcm_fpkm))

if(length(female_samples) == 0) {
  warning("No Female samples found for noise calculation! Using global lower quantile instead.")
  background_threshold <- quantile(dcm_fpkm, 0.10) # Fallback to bottom 10%
} else {
  # This is the line that failed before. 
  # Now that dcm_fpkm is guaranteed to be a matrix, it will work.
  noise_values <- dcm_fpkm[y_genes_present, female_samples]
  background_threshold <- mean(noise_values, na.rm = TRUE)
}

print(paste("Background Noise Threshold (FPKM):", round(background_threshold, 4)))

# The Threshold = The average "noise" signal found in these negative controls
background_threshold <- mean(noise_values, na.rm = TRUE)

print(paste("Background Noise Threshold (FPKM):", round(background_threshold, 4)))

# 5. APPLY FILTER TO DATASET
# We keep genes where the MEAN expression across the cohort is > background noise
gene_means <- rowMeans(dcm_fpkm)
keep_genes <- gene_means > background_threshold

# Subset the raw count matrix
dcm_expr_filtered <- dcm_expr_raw[keep_genes, ]

print(paste("Original Gene Count:", nrow(dcm_expr_raw)))
print(paste("Filtered Gene Count (Y-Chrom Rule):", nrow(dcm_expr_filtered)))


# 2. Install edgeR specifically
BiocManager::install("edgeR", force = TRUE)
library(edgeR)



# A. Create a DGEList object (standard R structure for RNA-seq)
dge <- DGEList(counts = dcm_expr_raw)

# B. Filter genes: Keep genes expressed in at least 50% of patients
# This is crucial for WGCNA stability later.

keep <- rowSums(cpm(dge) > 1) >= (ncol(dge) * 0.75)
dge_filtered <- dge[keep, , keep.lib.sizes = FALSE]

# C. Calculate Log2-CPM (Matches Yuan et al. Methodology)
dcm_expr_norm <- cpm(dge_filtered, log = TRUE)

print(paste("Original Gene Count:", nrow(dcm_expr_raw)))
print(paste("Filtered Gene Count (Ready for Clustering):", nrow(dcm_expr_norm)))


#Result
# "Original Gene Count: 20781"
#"Filtered Gene Count (Ready for Clustering): 5915"

#DETERMINE OPTIMAL CLUSTERS (NbClust)

install.packages("factoextra", dependencies = TRUE)
if (!require("factoextra")) install.packages("factoextra")
if (!require("NbClust")) install.packages("NbClust")

library(factoextra)
library(NbClust)

# 2. Prepare Data (Top variable genes only)
# Using too many genes makes validation slow/impossible.
# We use the 'dcm_expr_variable' created in Step 2.
# We transpose because these functions expect Rows = Patients.


# 1. Identify Top 1000 Variable Genes (Based on SD)
gene_vars <- apply(dcm_expr_norm, 1, sd)
top_1000_genes <- names(sort(gene_vars, decreasing = TRUE))[1:1000]

# 2. Subset and SCALE the data
# We scale the rows (genes), then transpose so Patients are rows for NbClust
val_matrix <- (scale(t(dcm_expr_norm[top_1000_genes, ])))

# 3. Method 1: The "Elbow Method" (Visual Check)
# Does adding more clusters reduce variance enough to be worth it?
fviz_nbclust(val_matrix, kmeans, method = "wss") +
  labs(subtitle = "Elbow Method")

# 4. Method 2: The "Silhouette Method" (Quality Check)
# Which k gives the most distinct/separated groups?
fviz_nbclust(val_matrix, kmeans, method = "silhouette") +
  labs(subtitle = "Silhouette Method")

# We calculate variance for each column (gene) and keep only those > 0.
val_matrix_clean <- val_matrix[, apply(val_matrix, 2, var, na.rm = TRUE) != 0]

# 2. CLEANING: Handle any remaining NAs
# Just in case, replace any NAs with 0 (though logCPM usually doesn't have them)
val_matrix_clean[is.na(val_matrix_clean)] <- 0

print(paste("Dimensions after cleaning:", nrow(val_matrix_clean), "Patients x", ncol(val_matrix_clean), "Genes"))

# 3. RUN NBCLUST (Use index = 'silhouette' or 'kl')
# 'silhouette' 

set.seed(123)
res_nb <- NbClust(val_matrix_clean, 
                  distance = "euclidean", 
                  min.nc = 2, max.nc = 6, 
                  method = "kmeans", 
                  index = "silhouette") # <--- CHANGED FROM 'all' TO 'silhouette'
print(res_nb$Best.nc)

# 5. VISUALIZE
fviz_nbclust(val_matrix_clean, kmeans, method = "silhouette") +
  labs(title = "Optimal Number of Clusters (Silhouette Method)")

# ==============================================================================
# PHASE 4: VISUAL VALIDATION VIA PCA
# Rationale: Project 1,000 genes into 2D space to see cluster separation.
# ==============================================================================

# ==============================================================================
# STEP 5: FINAL CLUSTERING ASSIGNMENT (k=4)
# Rationale: Selected k=4 based on Elbow Method and alignment with 
# Verdonschot et al. (2021) phenogrouping methodology.
# ==============================================================================

# 1. SET THE CHOSEN K
final_k <- 4

# 2. PERFORM HIERARCHICAL CLUSTERING
# We use the clean, variable gene matrix you created in the previous step
dist_matrix <- dist(val_matrix_clean, method = "euclidean")
hc_res <- hclust(dist_matrix, method = "ward.D2")

# 3. ASSIGN CLUSTERS
cluster_assignments <- cutree(hc_res, k = final_k)


# 4. MERGE WITH METADATA
# Ensure we are assigning to the correct patients
if(all(rownames(dcm_meta) == names(cluster_assignments))) {
  dcm_meta$Endotype <- as.factor(cluster_assignments)
  message("SUCCESS: Patients assigned to 4 Molecular Endotypes.")
} else {
  stop("CRITICAL ERROR: Patient names do not match!")
}

# 5. CHECK CLUSTER SIZES
# You want to ensure no cluster is too small (e.g., <10 patients)
print("--- Patient Count per Cluster ---")
print(table(dcm_meta$Endotype))

# ------------------------------------------------------------------------------
# VISUALIZATION: THE DENDROGRAM (Manuscript Figure)
# ------------------------------------------------------------------------------
if (!require("factoextra")) install.packages("factoextra")
library(factoextra)

fviz_dend(hc_res, 
          k = final_k, 
          cex = 0.5,                
          k_colors = "jco",         
          rect = TRUE,              
          rect_border = "jco", 
          rect_fill = TRUE,
          main = "DCM Molecular Endotypes (Replicating Verdonschot et al.)",
          show_labels = FALSE)

# ==============================================================================
# PHASE 5A: CLINICAL CHARACTERIZATION (VALIDATING CLUSTER 4)
# Rationale: Determine if the small cluster (n=9) represents a severe phenotype.
# ==============================================================================
if (!require("ggsci")) install.packages("ggsci")
library(ggsci)
library(ggplot2)
library(ggpubr)

# 1. Visualize LVEF (Severity) by Endotype
# We use the 'Endotype' column we created in the previous step
p_lvef <- ggplot(dcm_meta, aes(x = Endotype, y = LVEF, fill = Endotype)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.5) + # Add dots to see the 9 patients
  stat_compare_means(method = "kruskal.test", label.y = 50) + 
  labs(title = "Is Cluster 4 the 'Severe' Group?", y = "LVEF (%)") +
  theme_minimal() +
  scale_fill_jco()

# 2. Visualize Age by Endotype
p_age <- ggplot(dcm_meta, aes(x = Endotype, y = age, fill = Endotype)) +
  geom_boxplot() +
  stat_compare_means(method = "kruskal.test", label.y = 90) +
  labs(title = "Age Distribution", y = "Age (Years)") +
  theme_minimal() +
  scale_fill_jco()

# 3. Print Plots
gridExtra::grid.arrange(p_lvef, p_age, ncol = 2)

# 4. Summary Table of Means
print(aggregate(cbind(LVEF, age) ~ Endotype, data = dcm_meta, FUN = mean))

# ==============================================================================
# PHASE 6: DIFFERENTIAL EXPRESSION (CHARACTERIZING THE ENDOTYPES)
# Rationale: Identify unique gene signatures to name the clusters (e.g., Fibrotic).
# ==============================================================================

library(limma)
library(dplyr)

# 1. Create the Design Matrix
# This tells R we are comparing Endotype 1 vs 2 vs 3 vs 4
design <- model.matrix(~0 + dcm_meta$Endotype)
colnames(design) <- c("E1", "E2", "E3", "E4")

# 2. Fit the Linear Model
# We use the full normalized data (dcm_expr_norm), not just the top 2000 genes
fit <- lmFit(dcm_expr_norm[, rownames(dcm_meta)], design)

# 3. Create Contrasts (One-vs-All)
# We want to find what makes Cluster 4 unique compared to everyone else.
contrast_matrix <- makeContrasts(
  E1_unique = E1 - (E2 + E3 + E4)/3,
  E2_unique = E2 - (E1 + E3 + E4)/3,
  E3_unique = E3 - (E1 + E2 + E4)/3,
  E4_unique = E4 - (E1 + E2 + E3)/3,
  levels = design
)

fit2 <- contrasts.fit(fit, contrast_matrix)
fit2 <- eBayes(fit2)

# 4. Function to Get Top Genes for a Cluster
get_top_markers <- function(cluster_name) {
  top <- topTable(fit2, coef = cluster_name, number = 20, adjust.method = "fdr")
  return(top)
}

# 5. Extract and View the Top Drivers for Cluster 4 (The small group)
print("--- TOP 20 GENES DRIVING CLUSTER 4 ---")
print(get_top_markers("E4_unique"))

# 6. Extract Top Drivers for Cluster 1
print("--- TOP 20 GENES DRIVING CLUSTER 1 ---")
print(get_top_markers("E1_unique"))

# 7. Extract Top Drivers for Cluster 2
print("--- TOP 20 GENES DRIVING CLUSTER 1 ---")
print(get_top_markers("E2_unique"))



# ==============================================================================
# PHASE 6B: ID TO GENE NAME CONVERSION 
# ==============================================================================

# 1. Extract the results table for Cluster 4 
# We get the top 20 genes specifically for E4
results_E4 <- topTable(fit2, coef = "E4_unique", number = 20, adjust.method = "fdr")
results_E3 <- topTable(fit2, coef = "E3_unique", number = 20, adjust.method = "fdr")
results_E2 <- topTable(fit2, coef = "E2_unique", number = 20, adjust.method = "fdr")
results_E1 <- topTable(fit2, coef = "E1_unique", number = 20, adjust.method = "fdr")

# 2. Get the list of Ensembl IDs from the row names
cluster_E4 <- rownames(results_E4)
cluster_E3 <- rownames(results_E3)
cluster_E2 <- rownames(results_E2)
cluster_E1 <- rownames(results_E1)

# 3. Connect to the Ensembl Database

library(biomaRt)
ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")

# 4. Search for the Gene Names

gene_map4 <- getBM(attributes = c("ensembl_gene_id", "hgnc_symbol", "description"),
                  filters = "ensembl_gene_id",
                  values = cluster_E4,
                  mart = ensembl)
gene_map3 <- getBM(attributes = c("ensembl_gene_id", "hgnc_symbol", "description"),
                   filters = "ensembl_gene_id",
                   values = cluster_E3,
                   mart = ensembl)
gene_map2 <- getBM(attributes = c("ensembl_gene_id", "hgnc_symbol", "description"),
                   filters = "ensembl_gene_id",
                   values = cluster_E2,
                   mart = ensembl)
gene_map1 <- getBM(attributes = c("ensembl_gene_id", "hgnc_symbol", "description"),
                   filters = "ensembl_gene_id",
                   values = cluster_E1,
                   mart = ensembl)


# 5. Add the Names to your Table

results_E4$Symbol <- gene_map4$hgnc_symbol[match(rownames(results_E4), gene_map4$ensembl_gene_id)]
results_E4$Description <- gene_map4$description[match(rownames(results_E4), gene_map4$ensembl_gene_id)]

results_E3$Symbol <- gene_map3$hgnc_symbol[match(rownames(results_E3), gene_map3$ensembl_gene_id)]
results_E3$Description <- gene_map3$description[match(rownames(results_E3), gene_map3$ensembl_gene_id)]

results_E2$Symbol <- gene_map2$hgnc_symbol[match(rownames(results_E2), gene_map2$ensembl_gene_id)]
results_E2$Description <- gene_map2$description[match(rownames(results_E2), gene_map2$ensembl_gene_id)]

results_E1$Symbol <- gene_map1$hgnc_symbol[match(rownames(results_E1), gene_map1$ensembl_gene_id)]
results_E1$Description <- gene_map1$description[match(rownames(results_E1), gene_map1$ensembl_gene_id)]

# 6. Reorder columns so the Name is first (Easier to read)
final_table_E4 <- results_E4[, c("Symbol", "logFC", "adj.P.Val", "Description")]
final_table_E3 <- results_E3[, c("Symbol", "logFC", "adj.P.Val", "Description")]
final_table_E2 <- results_E2[, c("Symbol", "logFC", "adj.P.Val", "Description")]
final_table_E1 <- results_E1[, c("Symbol", "logFC", "adj.P.Val", "Description")]

# 7. Print the Result
print("--- TOP GENES FOR CLUSTER 4 (With Names) ---")
print(final_table_E4)

print("--- TOP GENES FOR CLUSTER 3 (With Names) ---")
print(final_table_E3)

print("--- TOP GENES FOR CLUSTER 2(With Names) ---")
print(final_table_E2)

print("--- TOP GENES FOR CLUSTER 1 (With Names) ---")
print(final_table_E1)

# 1. Define the filename (It will save in your current working directory)
file_name4 <- "Cluster4_Top_Drivers.csv"
file_name3 <- "Cluster3_Top_Drivers.csv"
file_name2 <- "Cluster2_Top_Drivers.csv"
file_name1 <- "Cluster1_Top_Drivers.csv"


# 2. Export the table
# row.names = TRUE keeps the Ensembl IDs in the first column
write.csv(final_table_E4, file = file_name4, row.names = TRUE)
write.csv(final_table_E3, file = file_name3, row.names = TRUE)
write.csv(final_table_E2, file = file_name2, row.names = TRUE)
write.csv(final_table_E1, file = file_name1, row.names = TRUE)


# ==============================================================================
# PHASE 7: ROBUST PATHWAY ENRICHMENT (Using Top 200 Genes)
# Rationale: Use a larger gene list to find the biological story for each cluster.
# ==============================================================================

library(gprofiler2)
library(dplyr)
library(limma)
library(ggplot2)

# 1. Define a Function to Analyze Any Cluster
analyze_cluster_pathways <- function(cluster_name, cluster_coef) {
  
  # A. Get Top 200 Genes (instead of just 20) to capture the whole pathway
  # We use the existing 'fit2' object from Phase 6
  top_genes_table <- topTable(fit2, coef = cluster_coef, number = 200, adjust.method = "fdr")
  
  # B. Separate into UP and DOWN regulated pathways
  # This is critical! We want to know what is turning ON vs turning OFF.
  genes_up <- rownames(top_genes_table)[top_genes_table$logFC > 0]
  genes_down <- rownames(top_genes_table)[top_genes_table$logFC < 0]
  
  # C. Run Enrichment on UPREGULATED Genes (What is driving the phenotype?)
  if(length(genes_up) > 10) {
    gost_up <- gost(query = genes_up, organism = "hsapiens", sources = c("GO:BP", "REAC", "KEGG"))
    
    if (!is.null(gost_up$result)) {
      print(paste("---", cluster_name, ": TOP UPREGULATED PATHWAYS ---"))
      # Show top 5 terms
      print(head(gost_up$result[order(gost_up$result$p_value), c("term_name", "p_value")], 5))
      
      # Plot
      p <- gostplot(gost_up, capped = FALSE, interactive = FALSE) +
        ggtitle(paste(cluster_name, "- Upregulated Processes"))
      print(p)
    } else {
      print(paste("No significant upregulated pathways for", cluster_name))
    }
  }
  
  # D. Run Enrichment on DOWNREGULATED Genes (What is failing?)
  if(length(genes_down) > 10) {
    gost_down <- gost(query = genes_down, organism = "hsapiens", sources = c("GO:BP", "REAC", "KEGG"))
    
    if (!is.null(gost_down$result)) {
      print(paste("---", cluster_name, ": TOP DOWNREGULATED PATHWAYS ---"))
      print(head(gost_down$result[order(gost_down$result$p_value), c("term_name", "p_value")], 5))
    }
  }
}

# 2. Analyze Cluster 4 (The Severe/Small Group)
# We expect to see "Metabolism" or "Cell Structure" in the DOWN list.
analyze_cluster_pathways("Cluster 4 (Severe)", "E4_unique")

# 3. Analyze Cluster 1 (The Active Group)
# We expect to see "Immune" or "Stress" in the UP list.
analyze_cluster_pathways("Cluster 1", "E1_unique")

analyze_cluster_pathways("Cluster 2", "E2_unique")
analyze_cluster_pathways("Cluster 3", "E3_unique")

# ==============================================================================
# PHASE 8: PREDICTING miRNA DRIVERS
# Rationale: Find which miRNAs target the "Adhesion" genes downregulated in Cluster 4.
# ==============================================================================

library(gprofiler2)

# 1. Get the list of DOWNREGULATED genes in Cluster 4 (The Adhesion Genes)
# We use the same 'fit2' object from Phase 6
top_genes_table <- topTable(fit2, coef = "E4_unique", number = 300, adjust.method = "fdr")
genes_down_c4 <- rownames(top_genes_table)[top_genes_table$logFC < 0]

# 2. Run miRNA Motif Enrichment
# We ask gProfiler: "Do these genes share a common miRNA binding site?"
gost_mirna <- gost(query = genes_down_c4, 
                   organism = "hsapiens", 
                   sources = c("MIRNA", "TF")) # Look for miRNAs and Transcription Factors

# 3. Check the Results
if (!is.null(gost_mirna$result)) {
  
  # Filter for miRNA results only
  mirna_results <- gost_mirna$result[grep("miR", gost_mirna$result$term_name), ]
  
  print("--- PREDICTED miRNA DRIVERS FOR CLUSTER 4 ---")
  print(head(mirna_results[, c("term_name", "p_value")], 10))
  
  # 4. EXPORT FOR MANUSCRIPT
  # This list suggests which miRNAs are the "Master Regulators"
  write.csv(mirna_results, "Cluster4_Predicted_miRNA_Drivers.csv")
  
} else {
  print("No statistically significant miRNA motifs found in this gene list.")
}

# ==============================================================================
# PHASE 9: VALIDATING WITH YOUR EXTERNAL miRNA 
# ==============================================================================
my_mirna_list <- read.csv("Table2_Differential_Expression_Results_miRNAs.csv")

# 3. EXTRACT IDs
# We check if your Ensembl IDs exist in the main dataset
target_ids <- my_mirna_list$EnsemblGeneID
target_symbols <- my_mirna_list$gene_symbol

print(paste("Loaded", length(target_ids), "miRNAs from your file."))

# 1. Install & Load the Heatmap Package
if (!require("pheatmap")) install.packages("pheatmap")
library(pheatmap)
library(readr)
library(dplyr)
library(limma)

# ==============================================================================
# PHASE 9 (SAFETY CHECK): VERSION-AGNOSTIC MATCHING
# Rationale: Handle ID formats like "ENSG0000.1" vs "ENSG0000"
# ==============================================================================

# 1. Clean Your List IDs (Remove .1, .2 etc)
clean_target_ids <- gsub("\\..*", "", my_mirna_list$EnsemblGeneID)

# 2. Clean Dataset IDs
clean_dataset_ids <- gsub("\\..*", "", rownames(dcm_expr_norm))

# 3. Check Intersection Again
common_clean <- intersect(clean_dataset_ids, clean_target_ids)

print(paste("Strict Match Found:", length(intersect(rownames(dcm_expr_norm), gost_mirna$EnsemblGeneID))))
print(paste("Loose (Clean) Match Found:", length(common_clean)))

if(length(common_clean) > 0) {
  print("Found matches after cleaning IDs! Generating Heatmap...")
  
  # Find indices of the matches
  match_ind <- which(clean_dataset_ids %in% clean_target_ids)
  
  # Subset using indices
  mirna_subset <- dcm_expr_norm[match_ind, rownames(dcm_meta)]
  
  # Try to map names (approximate)
  # We just use the IDs for now to avoid errors
  pheatmap(mirna_subset,
           annotation_col = data.frame(Endotype = dcm_meta$Endotype, row.names=rownames(dcm_meta)),
           scale = "row",
           main = "Target miRNAs (Version-Cleaned)",
           show_rownames = TRUE)
} else {
  print("CONFIRMED: Your dataset definitely does not contain these miRNAs.")
  print("Proceed with the Phase 8 (Target Prediction) results for your manuscript.")
}

# ==============================================================================
# PHASE 9 (VISUALIZATION FIX): READABLE HEATMAP & PDF EXPORT
# ==============================================================================

library(pheatmap)

# 1. Define File Name (Saves to your project folder)
# PDF files allow you to zoom in without blurriness
pdf("Target_miRNAs_Heatmap_Zoomed.pdf", width = 10, height = 15) 

# 2. Generate Heatmap with Formatting Controls
pheatmap(mirna_subset,
         annotation_col = data.frame(Endotype = dcm_meta$Endotype, row.names=rownames(dcm_meta)),
         scale = "row",          # Shows relative expression (Red=High, Blue=Low)
         
         # --- READABILITY SETTINGS ---
         fontsize_row = 10,      # Increases font size of the IDs
         cellheight = 12,        # Forces each row to be taller (prevents overlapping)
         cellwidth = 1,          # Adjusts width if patients are too squashed
         border_color = NA,      # Removes grid lines for a cleaner look
         
         # --- LABELS ---
         show_rownames = TRUE,   # Ensure IDs are visible
         show_colnames = FALSE,  # Hide patient IDs (too messy)
         main = "Target miRNAs across DCM Endotypes"
)

# 3. Close the file (Crucial step!)
dev.off() 

# 4. Notify User
print("Success! Open the file 'Target_miRNAs_Heatmap_Zoomed.pdf' in your folder to see the IDs clearly.")

# ==============================================================================
# PHASE 9B: EXTRACT TOP miRNAs FROM HEATMAP DATA
# Rationale: Identify which miRNAs are most Upregulated (Red) in each cluster.
# ==============================================================================

library(dplyr)
library(tidyr)

# 1. Calculate Z-Scores (This mimics the heatmap scaling)
# We calculate how many standard deviations a value is from the mean.
cal_z_score <- function(x) {
  (x - mean(x)) / sd(x)
}

# Apply to the subset of miRNAs we found
mirna_z_matrix <- t(apply(mirna_subset, 1, cal_z_score))

# 2. Combine with Metadata
# We need to know which patient belongs to which cluster
z_data <- as.data.frame(t(mirna_z_matrix))
z_data$Endotype <- dcm_meta[rownames(z_data), "Endotype"]

# 3. Calculate Average Z-Score per Cluster
cluster_means <- z_data %>%
  group_by(Endotype) %>%
  summarise(across(everything(), mean, na.rm = TRUE)) %>%
  pivot_longer(cols = -Endotype, names_to = "miRNA", values_to = "Z_Score")

# 4. Extract Top 5 "Reddest" (Highest Expression) miRNAs for each Cluster
get_top_mirnas <- function(cluster_num) {
  top_mirs <- cluster_means %>%
    filter(Endotype == cluster_num) %>%
    arrange(desc(Z_Score)) %>% # Sort largest to smallest
    head(5)
  return(top_mirs)
}

# 5. PRINT THE RESULTS
print("--- TOP miRNAs FOR CLUSTER 1 (Proteotoxic) ---")
print(get_top_mirnas(1))

print("--- TOP miRNAs FOR CLUSTER 2 (Transcriptional-Null) ---")
print(get_top_mirnas(2))

print("--- TOP miRNAs FOR CLUSTER 3 (Stress-Activated) ---")
print(get_top_mirnas(3))

print("--- TOP miRNAs FOR CLUSTER 4 (Structural Failure) ---")
print(get_top_mirnas(4))


# ==============================================================================
# PHASE 10: MECHANISTIC CORRELATION CHECK (The "Proof")
# Rationale: Test if High miRNA correlates with Low Target Gene (Negative Slope).
# ==============================================================================

library(ggplot2)
library(ggpubr)

# ------------------------------------------------------------------------------
# 1. DEFINE YOUR PAIR (REPLACE THESE IDs WITH YOUR CANDIDATES!)
# ------------------------------------------------------------------------------
# We test if a miRNA targets an Adhesion Gene in Cluster 4.

# miRNA ID (Look at your Phase 9b Results for the top red miRNA)
# e.g., Let's pretend this is miR-27b (Replace with your ACTUAL ID from the table)
mirna_id <- "ENSG00000265452" 

# Target Gene ID (Look at your Phase 6b Results for the top downregulated gene)
# e.g., Let's pretend this is PCDHGA2 (Replace with your ACTUAL ID)
target_gene_id <- "ENSG00000081853" 

# Optional: Give them nice names for the plot
mirna_name <- "miR-27b"
gene_name <- "PCDHGA2 (Cell Adhesion)"

# ------------------------------------------------------------------------------
# 2. EXTRACT DATA & CHECK EXISTENCE
# ------------------------------------------------------------------------------
if(mirna_id %in% rownames(dcm_expr_norm) & target_gene_id %in% rownames(dcm_expr_norm)) {
  
  # Extract expression values for all patients
  # We transpose (t) so columns become variables
  df_cor <- data.frame(
    miRNA_Exp = dcm_expr_norm[mirna_id, ],
    Gene_Exp = dcm_expr_norm[target_gene_id, ],
    Endotype = dcm_meta$Endotype
  )
  
  # ----------------------------------------------------------------------------
  # 3. CALCULATE CORRELATION & PLOT
  # ----------------------------------------------------------------------------
  # We look for a NEGATIVE 'R' value (e.g., R = -0.5)
  
  p <- ggplot(df_cor, aes(x = miRNA_Exp, y = Gene_Exp)) +
    geom_point(aes(color = Endotype), size = 3, alpha = 0.8) + # Color by cluster
    geom_smooth(method = "lm", color = "black", se = TRUE) +   # Add the trend line
    stat_cor(method = "pearson", label.x.npc = "middle") +     # Show R and p-value
    labs(
      title = paste("Mechanistic Link:", mirna_name, "vs", gene_name),
      subtitle = "Hypothesis: Negative Correlation (Downward Slope)",
      x = paste(mirna_name, "Expression (Log2)"),
      y = paste(gene_name, "Expression (Log2)")
    ) +
    theme_minimal() +
    scale_color_manual(values = c("#0073C2FF", "#EFC000FF", "#868686FF", "#CD534CFF"))
  
  print(p)
  
} else {
  print("ERROR: One of the IDs was not found in the dataset.")
  print("Please check your CSV files and copy the 'ENSG...' ID exactly.")
}


# ==============================================================================
# PHASE 4: VISUAL VALIDATION VIA PCA
# Rationale: Project 1,000 genes into 2D space to see cluster separation.
# ==============================================================================

library(factoextra)
library(ggplot2)

# 1. Run the PCA
# We use the scaled matrix from Phase 3
pca_res <- prcomp(val_matrix_scaled, scale. = FALSE) 

# 2. Create the Plot
# 'habillage' colors the points by your cluster assignments
pca_plot <- fviz_cluster(list(data = val_matrix_scaled, cluster = dcm_meta$Endotype),
                         palette = c("#0073C2FF", "#EFC000FF", "#868686FF", "#CD534CFF"),
                         geom = "point",
                         ellipse.type = "convex", 
                         ggtheme = theme_minimal(),
                         main = "PCA: 2D Projection of DCM Endotypes") +
  labs(subtitle = "Based on Top 1,000 Variable Genes")

# 3. View the Plot
print(pca_plot)
