```{r}

# ==============================================================================
# Script: 03_Cluster_Characterization_Full.R
# Purpose: Comprehensive 3-way comparison of DCM molecular subtypes
# ==============================================================================

library(tidyverse)
library(here)
library(limma)
library(edgeR)
library(clusterProfiler)
library(org.Hs.eg.db) 
library(pheatmap)
library(ggvenn) # Install if needed: install.packages("ggvenn")

# 1. Load Data (Updated Paths)
# Note: Ensure you have run the "Safe Merge" script first to get the corrected sampleInfo
sampleInfo <- readRDS(here("sandbox", "sadegh", "results", "sampleInfo_with_clusters.rds"))
expression <- readRDS(here("sandbox", "sadegh", "results", "expression.rds"))

# Filter for DCM samples only
dcm_samples <- sampleInfo %>% 
  filter(etiology == "DCM" & !is.na(DCM_Subtype)) %>% 
  rownames()

dcm_expr <- expression[, dcm_samples]
dcm_meta <- sampleInfo[dcm_samples, ]

# 2. Design Matrix & Contrasts
dcm_meta$DCM_Subtype <- factor(dcm_meta$DCM_Subtype)

# We include Age/Gender/Batch to correct for them (even if Gender is NS, it's good practice)
design <- model.matrix(~0 + DCM_Subtype + age + gender + Library.Pool, data = dcm_meta)
colnames(design) <- gsub("DCM_Subtype", "", colnames(design))

# Fit Linear Model
fit <- lmFit(dcm_expr, design)

# Define ALL 3 Pairwise Contrasts
cm <- makeContrasts(
  C1_vs_C2 = Cluster_1 - Cluster_2,
  C1_vs_C3 = Cluster_1 - Cluster_3,
  C2_vs_C3 = Cluster_2 - Cluster_3,
  levels = design
)

fit2 <- contrasts.fit(fit, cm)
fit2 <- eBayes(fit2, trend = TRUE)

# 3. Extract Results for All Comparisons
get_degs <- function(fit_obj, coef_name) {
  topTable(fit_obj, coef = coef_name, number = Inf) %>%
    rownames_to_column("EnsemblID") %>%
    mutate(Comparison = coef_name)
}

all_degs <- bind_rows(
  get_degs(fit2, "C1_vs_C2"),
  get_degs(fit2, "C1_vs_C3"),
  get_degs(fit2, "C2_vs_C3")
)

# Save the master table
write_tsv(all_degs, here("sandbox", "sadegh", "results", "All_Clusters_DE_Results.txt"))

# 4. Pathway Enrichment Loop (The "Bio-Automation")
# We loop through each comparison to generate a Dotplot

comparisons <- c("C1_vs_C2", "C1_vs_C3", "C2_vs_C3")

for(comp in comparisons) {
  
  # Select SIGNIFICANT UPREGULATED genes for the first group in the pair
  # (e.g., for C1_vs_C2, genes higher in C1)
  sig_genes <- all_degs %>%
    filter(Comparison == comp) %>%
    filter(adj.P.Val < 0.05 & logFC > 0.58) %>% 
    pull(EnsemblID)
  
  print(paste("Processing:", comp, "- Genes found:", length(sig_genes)))
  
  if(length(sig_genes) > 10) { # Only run if we have enough genes
    
    ego <- enrichGO(
      gene = sig_genes,
      OrgDb = org.Hs.eg.db,
      keyType = "ENSEMBL",
      ont = "BP",
      pAdjustMethod = "BH",
      pvalueCutoff = 0.05,
      qvalueCutoff = 0.05
    )
    
    if(!is.null(ego)) {
      # Save Dotplot
      dp <- dotplot(ego, showCategory = 15) + 
        ggtitle(paste("Enriched Pathways:", comp))
      
      ggsave(here("sandbox", "sadegh", "plots", paste0("GO_", comp, ".pdf")), dp, width=8, height=8)
    }
  }
}

# 5. Venn Diagram: How much overlap is there?
# Create a list of genes UP in Cluster 1 (vs 2) and UP in Cluster 1 (vs 3)
# This defines the "Core Cluster 1 Signature"
genes_C1_vs_C2 <- all_degs %>% filter(Comparison=="C1_vs_C2" & adj.P.Val<0.05 & logFC>0) %>% pull(EnsemblID)
genes_C1_vs_C3 <- all_degs %>% filter(Comparison=="C1_vs_C3" & adj.P.Val<0.05 & logFC>0) %>% pull(EnsemblID)

venn_data <- list(
  C1_vs_C2 = genes_C1_vs_C2,
  C1_vs_C3 = genes_C1_vs_C3
)

venn_plot <- ggvenn(venn_data, fill_color = c("#E41A1C", "#377EB8")) +
  ggtitle("Defining the Core Cluster 1 Signature")

ggsave(here("sandbox", "sadegh", "plots", "Venn_Cluster1_Signature.pdf"), venn_plot)



```




```{r}


design <- model.matrix(~0 + DCM_Subtype + age + gender + Library.Pool, data = dcm_meta)
colnames(design) <- gsub("DCM_Subtype", "", colnames(design))

fit <- lmFit(dcm_expr, design)

# 3. Define "One-vs-Rest" Contrasts
# We compare each cluster to the average of the other two
cm <- makeContrasts(
  C1_Identity = Cluster_1 - (Cluster_2 + Cluster_3)/2,
  C2_Identity = Cluster_2 - (Cluster_1 + Cluster_3)/2,
  C3_Identity = Cluster_3 - (Cluster_1 + Cluster_2)/2,
  levels = design
)

fit2 <- contrasts.fit(fit, cm)
fit2 <- eBayes(fit2, trend = TRUE)

# 4. Extract Markers and Run Enrichment
# We store the significant gene IDs in a list for the comparison plot later
cluster_genes_list <- list()

comparisons <- c("C1_Identity", "C2_Identity", "C3_Identity")
names(comparisons) <- c("Cluster 1", "Cluster 2", "Cluster 3") # Pretty names

for(i in 1:3) {
  comp_code <- comparisons[i]
  comp_name <- names(comparisons)[i]
  
  # Get UPREGULATED genes (logFC > 0) for this cluster
  # These are the genes that define this cluster's "High" expression traits
  top_genes <- topTable(fit2, coef = comp_code, number = Inf) %>%
    rownames_to_column("EnsemblID") %>%
    filter(adj.P.Val < 0.05 & logFC > 0.5) # Slight fold-change cutoff to reduce noise
  
  print(paste("Cluster", i, "Unique Markers:", nrow(top_genes)))
  
  # Save the gene list
  cluster_genes_list[[comp_name]] <- top_genes$EnsemblID
  
  # Run Enrichment (If genes found)
  if(nrow(top_genes) > 10) {
    ego <- enrichGO(
      gene = top_genes$EnsemblID,
      OrgDb = org.Hs.eg.db,
      keyType = "ENSEMBL",
      ont = "BP",
      pAdjustMethod = "BH",
      pvalueCutoff = 0.05
    )
    
    if(!is.null(ego)) {
      # Individual Dotplot
      dp <- dotplot(ego, showCategory = 15) + 
        ggtitle(paste("Pathophysiology of", comp_name))
      
      ggsave(here("sandbox", "sadegh", "plots", paste0("GO_Identity_", comp_name, ".pdf")), dp, width=9, height=7)
    }
  }
}

# 5. The "Killer Figure": CompareCluster Dotplot
# This puts all 3 clusters on one plot to show distinct functions
# (This is usually Figure 3 or 4 in high-impact papers)

print("Generating Comparative Dotplot...")
ck <- compareCluster(geneCluster = cluster_genes_list, 
                     fun = "enrichGO", 
                     OrgDb = org.Hs.eg.db,
                     keyType = "ENSEMBL",
                     ont = "BP")

# Visualize
final_plot <- dotplot(ck, showCategory = 5) + 
  ggtitle("Functional Divergence of DCM Subtypes") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggsave(here("sandbox", "sadegh", "plots", "CompareCluster_Dotplot.pdf"), final_plot, width=10, height=8)

print("Analysis Complete. Check 'plots/CompareCluster_Dotplot.pdf'")

```






```{r UMAP}

library(umap)    # install.packages("umap")
library(ggplot2)
library(dplyr)
library(ggrepel) # For nice labels

# A. Select Top Variable Genes (Standard Best Practice)
# Calculate variance for each gene
gene_vars <- apply(dcm_expr, 1, var)

# Keep top 2000 most variable genes (adjust as needed)
top_genes <- names(sort(gene_vars, decreasing = TRUE))[1:2000]
expr_filtered <- dcm_expr[top_genes, ]

# B. Transpose for UMAP
# UMAP/PCA expects Samples as ROWS and Genes as COLUMNS
pca_input <- t(expr_filtered)


# --- OPTION A: UMAP (Like your image Panel B) ---
umap_res <- umap(pca_input)
plot_coords <- data.frame(umap_res$layout)
colnames(plot_coords) <- c("Dim1", "Dim2")

# --- OPTION B: PCA (Alternative) ---
# pca_res <- prcomp(pca_input, scale. = TRUE)
# plot_coords <- data.frame(pca_res$x[, 1:2]) # Keep PC1 and PC2
# colnames(plot_coords) <- c("Dim1", "Dim2")

plot_data <- plot_coords %>%
  rownames_to_column("SampleID") %>%
  inner_join(dcm_meta %>% rownames_to_column("SampleID"), by = "SampleID")

# Calculate Centroids (The center point for labels 1, 2, 3)
centroids <- plot_data %>%
  group_by(DCM_Subtype) %>%
  summarise(
    Dim1 = mean(Dim1),
    Dim2 = mean(Dim2)
  )

p1 <- ggplot(plot_data, aes(x = Dim1, y = Dim2)) +
  
  # 1. The Points
  geom_point(aes(color = DCM_Subtype), size = 3, alpha = 0.8) +
  
  # 2. The Centroid Labels (The numbers 1, 2, 3)
  geom_label_repel(data = centroids, 
                   aes(label = DCM_Subtype, fill = DCM_Subtype), 
                   color = "white", fontface = "bold", size = 5, box.padding = 0.5) +
  
  # 3. Styling
  scale_color_manual(values = c("#FA8072", "#008B8B", "#E69F00")) + # Custom colors
  scale_fill_manual(values = c("#FA8072", "#008B8B", "#E69F00")) + 
  theme_bw() +
  labs(title = "UMAP of DCM Subtypes", x = "UMAP Dimension 1", y = "UMAP Dimension 2") +
  theme(legend.position = "right",
        panel.grid = element_blank(), # Remove grid for cleaner look
        axis.text = element_blank(),  # Often removed in UMAP plots
        axis.ticks = element_blank())

print(p1)
```



```{r PCA}


library(tidyverse)
library(ggrepel)

# 1. Preparation: Select Top Variable Genes
# PCA is sensitive to noise. We filter for the top 2000 most variable genes 
# to ensure the principal components reflect biological signal, not technical noise.
gene_vars <- apply(dcm_expr, 1, var)
top_genes <- names(sort(gene_vars, decreasing = TRUE))[1:2000]
pca_input <- t(dcm_expr[top_genes, ]) # Transpose: Samples must be rows

# 2. Run PCA
# center=TRUE and scale.=TRUE are critical for RNA-seq to normalize magnitude
pca_res <- prcomp(pca_input, center = TRUE, scale. = TRUE)

# 3. Extract Variance Explained (for Axis Labels)
# This tells us how much "information" is captured by PC1 and PC2
var_explained <- round(100 * (pca_res$sdev^2 / sum(pca_res$sdev^2)), 1)
pc1_lab <- paste0("PC1 (", var_explained[1], "%)")
pc2_lab <- paste0("PC2 (", var_explained[2], "%)")

# 4. Prepare Plotting Data
pca_data <- as.data.frame(pca_res$x) %>% 
  dplyr::select(PC1, PC2) %>% 
  rownames_to_column("SampleID") %>% 
  inner_join(dcm_meta %>% rownames_to_column("SampleID"), by = "SampleID")

# Calculate Centroids (Center points for labels)
centroids <- pca_data %>%
  group_by(DCM_Subtype) %>%
  summarise(
    PC1 = mean(PC1),
    PC2 = mean(PC2)
  )

# 5. Generate the Plot
pca_plot <- ggplot(pca_data, aes(x = PC1, y = PC2, color = DCM_Subtype)) +
  
  # A. The Points
  geom_point(size = 3, alpha = 0.8) +
  
  # B. The Highlight: Add Ellipses (Confidence Regions)
  # This draws a circle around the core 95% of samples in each cluster
  stat_ellipse(aes(fill = DCM_Subtype), geom = "polygon", alpha = 0.1, level = 0.95, show.legend = FALSE) +
  
  # C. Label the Centers
  geom_label_repel(data = centroids, aes(label = DCM_Subtype), 
                   color = "black", fontface = "bold", size = 5, box.padding = 0.5) +
  
  # D. Styling
  scale_color_manual(values = c("#FA8072", "#008B8B", "#E69F00")) + # Custom colors
  scale_fill_manual(values = c("#FA8072", "#008B8B", "#E69F00")) +
  theme_bw() +
  labs(title = "PCA of DCM Subtypes", 
       x = pc1_lab, 
       y = pc2_lab) +
  theme(
    panel.grid.minor = element_blank(),
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title = element_text(face = "bold")
  )

print(pca_plot)

# Save
ggsave(here("sandbox", "sadegh", "plots", "PCA_Clusters_Ellipses.pdf"), pca_plot, width=7, height=6)

ggsave(here("sandbox", "sadegh", "plots", "Complex_Dotplot.pdf"), p, width = 12, height = 10)

```




``` {r Enrichment}

library(tidyverse)
library(limma)
library(edgeR)
library(clusterProfiler)
library(org.Hs.eg.db)
library(here)

# ... [Load your data and create dcm_expr/dcm_meta as you did before] ...

# ---------------------------------------------------------
# 1. Design & Contrasts (Updated for flexibility)
# ---------------------------------------------------------
# Note: Your image shows 4 clusters and a "C1-2 vs C3-4" comparison. 
# Since your code has 3 clusters, I will show you how to set up the 
# comparisons to match the logic of the image.

# Create Design
dcm_meta$DCM_Subtype <- factor(dcm_meta$DCM_Subtype)
design <- model.matrix(~0 + DCM_Subtype + age + gender + Library.Pool, data = dcm_meta)
colnames(design) <- gsub("DCM_Subtype", "", colnames(design))

fit <- lmFit(dcm_expr, design)

# Define Contrasts
# If you want to replicate the "C1-2 vs C3" logic, you can add it here.
cm <- makeContrasts(
  C1_Identity = Cluster_1 - (Cluster_2 + Cluster_3)/2,
  C2_Identity = Cluster_2 - (Cluster_1 + Cluster_3)/2,
  C3_Identity = Cluster_3 - (Cluster_1 + Cluster_2)/2,
  # Example of a combined contrast (C1+C2 vs C3):
  C1_C3_vs_C2= (Cluster_1 + Cluster_3)/2 - Cluster_2,
  levels = design
)

fit2 <- contrasts.fit(fit, cm)
fit2 <- eBayes(fit2, trend = TRUE)

# ---------------------------------------------------------
# 2. Extract Markers (UP and DOWN separately)
# ---------------------------------------------------------
# To get the Red/Blue dots, we need separate lists for Up and Down genes.

gene_lists <- list()
comparisons <- colnames(cm) # Uses the names defined in makeContrasts

for(comp in comparisons) {
  # Get all results for this contrast
  res <- topTable(fit2, coef = comp, number = Inf) %>% 
    rownames_to_column("EnsemblID")
  
  # Filter UP (Red in your plot)
  up_genes <- res %>% 
    filter(adj.P.Val < 0.05 & logFC > 0.5) %>% 
    pull(EnsemblID)
  
  # Filter DOWN (Blue in your plot)
  down_genes <- res %>% 
    filter(adj.P.Val < 0.05 & logFC < -0.5) %>% 
    pull(EnsemblID)
  
  # Store in list with specific naming convention
  gene_lists[[paste0(comp, "__UP")]] <- up_genes
  gene_lists[[paste0(comp, "__DOWN")]] <- down_genes
}

# Check how many genes we found
print(sapply(gene_lists, length))

# ---------------------------------------------------------
# 3. Run Comparison Enrichment
# ---------------------------------------------------------
# compareCluster does the heavy lifting of running enrichment on all lists at once
all_genes_tested <- rownames(dcm_expr)
ck <- compareCluster(
  universe=all_genes_tested,
  geneCluster = gene_lists, 
  fun = "enrichGO",
  OrgDb = org.Hs.eg.db,
  keyType = "ENSEMBL",
  ont = "BP",              # Biological Process
  pAdjustMethod = "BH",
  pvalueCutoff = 0.05,
  qvalueCutoff = 0.2
)

# ---------------------------------------------------------
# 4. Visualization (Recreating the Image)
# ---------------------------------------------------------

# We need to process the result to split the "Cluster__Direction" names 
# back into two columns for plotting.

df_plot <- ck@compareClusterResult %>%
  separate(Cluster, into = c("Group", "Direction"), sep = "__") %>%
  mutate(
    # Set Direction as factor to control color (Up=Red, Down=Blue)
    Direction = factor(Direction, levels = c("DOWN", "UP")), 
    # Log transform p-value for size
    logP = -log10(p.adjust)
  )

# --- FILTERING (Crucial step!) ---
# The image you uploaded is manually curated. It does not show ALL terms.
# You must filter 'df_plot' to keep only the terms of interest or top terms.
# Here is an example of keeping the top 3 terms per group:

top_terms <- df_plot %>%
  group_by(Group, Direction) %>%
  slice_min(p.adjust, n = 3) %>%
  pull(Description)

df_filtered <- df_plot %>% filter(Description %in% top_terms)

# --- PLOTTING ---
ggplot(df_filtered, aes(x = Group, y = Description)) +
  # The points
  geom_point(aes(size = logP, color = Direction)) +
  
  # Match the colors from the image (Blue for Down, Red for Up)
  scale_color_manual(values = c("DOWN" = "#2b8cbe", "UP" = "#e41a1c")) +
  
  # Clean up the theme
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.title = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  labs(size = "-log10(p-adj)", color = "Regulation")


```